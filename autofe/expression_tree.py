# import os
import time
import random
from typing import List, Tuple, Dict
# from collections import namedtuple
# from functools import partial

import numpy as np
import torch
from pytorch_functions import _Function, _function_map
# from graphviz import Digraph, Source
# from IPython.display import Image, display

from pytorch_functions import FEATURE_TYPE, DAY_INT_TYPE, MIN_INT_TYPE


class ToolBox:
    def __init__(self, function_set: List[_Function] = None, **kargs) -> None:
        super().__init__()

        if function_set:
            self.function_set = function_set
        else:
            self.function_set = []


        self.argument_types = set()
        for f in self.function_set:
            self.argument_types.update(f.argument_types)

        for _type in self.argument_types:
            # initialize argument types if available, otherwise None.
            setattr(self, _type, kargs.get(_type, []))

    def get_argument_types(self, unregistered=False):
        if unregistered is True:
            return {_type for _type in self.argument_types if getattr(self, _type) == []}
        else:
            return self.argument_types

    def register_type(self, name: str, candidates: List):
        assert name in self.argument_types, \
                f'type {name} not in the argument types of function_set.'
        setattr(self, name, candidates)

    def __str__(self) -> str:
        type_str = '\n'.join([f'{_type}, {getattr(self, _type)}' for _type in self.argument_types])
        function_set_str = ','.join(str(f) for f in self.function_set)
        return (f"function_set ({len(self.function_set)}"
                f" functions):\n{function_set_str}\n" + type_str)



def test_toolbox():
    function_set = list(_function_map.values())
    tb = ToolBox(function_set)
    feature_canditates = [f"f{i}" for i in range(20)]
    tb.register_type('feature', feature_canditates)
    tb.register_type(DAY_INT_TYPE, [2, 3, 5, 7, 10, 15])
    tb.register_type(MIN_INT_TYPE, [2, 3, 5, 6, 10, 15, 24])
    print(tb)

    return tb


class ExpressionTree:
    def __init__(self, node_type: str, toolbox: ToolBox, expression_depth: Tuple[int, int],
                 prob_mutate: float = 0.01, prob_crossover: float = 0.3) -> None:
        """A multi-child tree representing a expression generated by genetic programming framework.

        Parameters
        ----------
        node_type : str
            node type of the current node, should be one of `NODE_TYPES`.
        expression_depth : Tuple[int, int]
            tuple of minimum and maximum depth of the expression tree.
        prob_mutate: float
            probability of mutation for a particular node of a expression tree.
        prob_crossover: float
            probability of crossover between to expression trees.
        """
        self.node_type = node_type
        self.toolbox = toolbox

        self.expression_depth = expression_depth
        self.min_depth, self.max_depth = expression_depth
        self.prob_mutate = prob_mutate
        self.prob_crossover = prob_crossover
        self.node = None # should be one of feature_set, feature_terminals and int_terminals.
        self.children = []

    # def from_string(factor: str):
    #     idx = factor.index('(')
    #     node_name = factor[:idx]
    #     arguments = factor[idx+1:-1]

    def __str__(self) -> str:
        """String representation of expression of this ExpressionTree.

        Returns
        -------
        str
            string representation.
        """
        expression = ""
        if self.node_type == FEATURE_TYPE:
            if self.node in self.toolbox.function_set: #evaluate the feature
                children_str = ','.join([child.__str__() for child in self.children])
                expression = f"{self.node}({children_str})"

            elif self.node in getattr(self.toolbox, FEATURE_TYPE): # get the feature
                expression = str(self.node)
            else:
                raise Exception('evaluation error!  1')
        elif self.node_type == DAY_INT_TYPE or self.node_type == MIN_INT_TYPE:
            expression = str(self.node)
        else:
            raise Exception('evaluation error!  2')
        return expression

    def __eq__(self, other):
        return self.__str__() == other.__str__()

    def __hash__(self) -> int:
        return hash(self.__str__())

    def get_features(self, features=[]) -> List[str]:
        """Get all the original features (leaf nodes) of raw input in the ExpressionTree.

        Parameters
        ----------
        features : list, optional
            where collected features are stored, by default []

        Returns
        -------
        List[str]
            list of all features.
        """
        if self.node in getattr(self.toolbox, FEATURE_TYPE):
            features.append(self.node)
        for child in self.children:
            child.get_features(features)
        return features

    def subtree_mutate(self):
        """mutate(regenerate) a subtree starting from this node.
        """
        if random.random() < self.prob_mutate and \
            self.node_type == FEATURE_TYPE: # mutate at this node
            # print('mutation happens')
            self.generate_tree(grow=True, max_depth=2)
        for child in self.children: # mutate for children
            child.subtree_mutate()


    # def size(self, feature_only=True) -> int:
    #     """Compute (recursively) the number of nodes in this ExpressionTree.

    #     Parameters
    #     ----------
    #     feature_only : bool, optional
    #         whether only count feature (excluding int terminals), by default True

    #     Returns
    #     -------
    #     int
    #         number of requested nodes.
    #     """
    #     if feature_only:
    #         if self.node in getattr(self.toolbox, FEATURE_TYPE):
    #             return 1
    #         elif self.node in self.int_terminals:
    #             return 0
    #         elif self.node in getattr(self.toolbox, 'function_set'):
    #             pass
    #         else: # never should be here.
    #             raise Exception('The expression tree is problematic.')
    #     else:
    #         if self.node in (self.feature_terminals + self.int_terminals):
    #             return 1
    #         elif self.node in getattr(self.toolbox, 'function_set'):
    #                 pass
    #         else: # never should be here.
    #             raise Exception('The expression tree is problematic.')

    #     return 1 + sum([child.size(feature_only=feature_only) for child in self.children])


    def locate_node(self, count: List[int]): # count is a list with 1 element, by reference.
        """Locate particular node specified by the argument.

        Parameters
        ----------
        count : List[int]
            `number` (int) of the node

        Returns
        -------
        ExpressionTree
            the located node (ExpressionTree).

        Raises
        ------
        Exception
            [description]
        """
        if self.node_type == FEATURE_TYPE:
            count[0] -= 1
        if count[0] < 1:
            return self
        elif count[0] >= 1:
            ret = None
            for child in self.children:
                if count[0] >= 1:
                    ret = child.locate_node(count)
            return ret
        else:
            raise Exception('Never should be here.')


    # def cross_over(self, other):

    #     def _swap(node1, node2):
    #         """Swap two node.
    #         """
    #         def _copy(left, right):
    #             """Copy right node to left node.
    #             """
    #             left.node = right.node
    #             left.node_type = right.node_type
    #             left.children = right.children

    #         tmp = copy(node1)
    #         _copy(node1, node2) # node2 -> node1
    #         _copy(node2, tmp)  # node1 -> node2

    #     size1 = self.size(feature_only=True)
    #     node1 = self.locate_node([random.randint(1, size1)])

    #     # draw_tree(node1, fname='node1', footer='node1')
    #     size2 = other.size(feature_only=True)
    #     node2 = other.locate_node([random.randint(1, size2)])
    #     # draw_tree(node2, fname='node2', footer='node2')

    #     # draw_tree(node1, fname='node1_co', footer='node1_co')
    #     # draw_tree(node2, fname='node2_co', footer='node2_co')
    #     _swap(node1, node2)


    def generate_tree(self, grow: bool, max_depth: int, cur_depth: int = 0):
        if self.node_type == DAY_INT_TYPE:
            # int as argument of a function, which could be anywhere.
            candidates = getattr(self.toolbox, DAY_INT_TYPE)
        elif self.node_type == MIN_INT_TYPE:
                # int as argument of a function, which could be anywhere.
            candidates = getattr(self.toolbox, MIN_INT_TYPE)
        elif self.node_type == FEATURE_TYPE:
            if cur_depth < self.min_depth or \
                (cur_depth < self.max_depth and not grow): # must be functions
                # feature type here meout a function, not feature terminal.
                candidates = getattr(self.toolbox, 'function_set')
            elif cur_depth >= max_depth: # must be terminals
                # feature type here meout a feature terminal.
                candidates = getattr(self.toolbox, FEATURE_TYPE)

            else: # either a function or a feature terminal
                # grow must be True
                if random.random() > 0.5:
                    candidates = getattr(self.toolbox, 'function_set')
                else:
                    candidates = getattr(self.toolbox, FEATURE_TYPE)
        else:
            # should never be here.
            raise ValueError(f"node_type {self.node_type} not available.")

        # random sampling a node from the candidate list, this is customizable.
        self.node = np.random.choice(candidates, size=1).item()

        # generate children recursively
        if self.node in getattr(self.toolbox, 'function_set'):
            self.children.clear()  # clear all children, very important
            for arg_type in self.node.argument_types:
                # build tree
                tree = ExpressionTree(
                    arg_type,
                    toolbox=self.toolbox,
                    expression_depth=self.expression_depth)

                tree.generate_tree(grow, max_depth, cur_depth=cur_depth+1)
                self.children.append(tree)

    # def draw(self, fname: str, footer: str, save_dir: str='data'):
    #     def _draw(t, dot, count):
    #         node_name = str(count[0])
    #         # dot[0].node(node_name, t.node_label())
    #         dot[0].node(node_name, str(t.node))

    #         for child in t.children:
    #             count[0] +=1
    #             dot[0].edge(node_name, str(count[0]))
    #             _draw(child, dot, count)

    #     dot = [Digraph()]
    #     dot[0].attr(kw='graph', label=footer)
    #     count = [0]
    #     _draw(self, dot, count)

    #     if not os.path.isdir(save_dir):
    #         os.mkdir(save_dir)
    #     Source(dot[0], filename= f"{save_dir}/{fname}.gv", format='png').render()
    #     display(Image(filename=f"{save_dir}/{fname}.gv.png"))


    def eval(self, feature_tensor_dict: Dict) -> torch.Tensor:
        """Evaluate the expression tree recursively.

        Parameters
        ----------
        feature_tensor_dict: Dict
            dict of {`feature` name:  torch.Tensor of the feature (preferebly on GPU)}

        Returns
        -------
        torch.Tensor
            final output by evaluate the whole ExpressionTree.
        """
        out = None
        if self.node_type == FEATURE_TYPE:
            if self.node in getattr(self.toolbox, 'function_set'): #evaluate the feature
                assert isinstance(self.node, _Function)
                arguments = [child.eval(feature_tensor_dict) for child in self.children]

                if self.node.is_ts:
                    # batching the computation due to the huge memory consumption.
                    def _batched_eval(f: _Function, arguments: List, batch_size: int):
                        n_cross_sectional = arguments[0].shape[2]
                        indices_all = list(range(0, n_cross_sectional, batch_size)) + [n_cross_sectional]
                        res_list = []
                        for l, r in zip(indices_all[:-1], indices_all[1:]):
                            if f.arity == 3:
                                out = f(arguments[0][:, :, l:r],
                                        arguments[1][:, :, l:r],
                                        arguments[2])
                            elif self.node.arity == 2:
                                out = f(arguments[0][:, :, l:r],
                                        arguments[1])
                            else:
                                raise Exception("Never should be here.")
                            res_list.append(out)

                        # print(arguments[0].shape, arguments[1].shape, arguments[2])
                        out = torch.cat(res_list, dim=2)
                        return out

                    batch_size = 1200
                    # break if evaluation succeeds,
                    # otherwise halve the batch size and evaluate again until succeed.
                    while True:
                        try:
                            out = _batched_eval(self.node, arguments, batch_size)
                            break
                        except RuntimeError as e:
                            if 'out of memory' in str(e):
                                batch_size = batch_size // 2
                            else:
                                raise e

                    assert out is not None, 'batched evaluation failed.'
                else:
                    out = self.node(*arguments)

                # out = func(*arguments)

                # delete arguments that won't be used anymore, release memory.
                for arg in arguments:
                    del arg
                # torch.cuda.empty_cache()


            elif self.node in getattr(self.toolbox, FEATURE_TYPE): # get the feature
                out = feature_tensor_dict[self.node]
                # idx = self.feature_terminals.index(self.node)
                # out = self.data_tensor[:, idx: idx+1, :] # keep out a 3-D tensor
            else:
                raise Exception('evaluation error!  1')
        elif self.node_type == MIN_INT_TYPE or self.node_type == DAY_INT_TYPE:
            out = self.node
        else:
            raise Exception('evaluation error!  2')
        return out



if __name__ == '__main__':
    tb = test_toolbox()
    functions, arities = zip(*[(k, v.arity) for k, v in _function_map.items()])

    expression_depth = (2, 4)
    prob_mutate = 0.5
    prob_crossover = 0.5

    s = time.time()
    for i in range(4):
        if i % 200 == 199:
            print(f'==> tree {i}')
        t1 = ExpressionTree(
            node_type=FEATURE_TYPE,
            toolbox=tb,
            expression_depth=expression_depth,
            prob_mutate=prob_mutate,
            prob_crossover=prob_crossover,
            )
        t1.generate_tree(grow=True, max_depth=expression_depth[1], cur_depth=0)

        # t1.draw(fname=f'tree_{i}', footer=f'tree_{i}', save_dir='data')

        print('factor expression: ', t1)
    t = time.time()
    print(f"time elapsed: {t-s:.4f}s.")

        # features  = t1.get_features(features=[])
        # print('all features', features)

        # print(f'tree b')
        # t2 = ExpressionTree(
        #     node_type,
        #     x.cuda(),
        #     functions,
        #     feature_terminals,
        #     int_terminals,
        #     expression_depth,
        #     prob_mutate,
        #     prob_crossover
        #     )
        # t2.generate_tree(grow=True, max_depth=5, cur_depth=0)


        # feature_tensor_dict = {feature: torch.randn(670, 24, 4000).cuda() for feature in features}

        # # s = time.time()
        # res = t1.eval(feature_tensor_dict)

        # print(res.shape)
        # print(f"time elapsed: {time.time() - s}")
        # break
        # # print('size feature: ', t.size(feature_only=True))
        # # print('size all: ', t.size(feature_only=False))
        # n = t.size(feature_only=True)
        # count = [random.randint(1, n)]
        # print('count', count)
        # node = t.locate_node(count)

        # draw_tree(node, fname=f'tree{i}_locate', footer=f'tree{i}_locate')
        # break
        # t.mutate()
        # draw_tree(t, fname=f'tree_mutate{i}', footer=f'tree_mutate{i}')

        # import time
        # s = time.time()
        # res = t.eval()

        # # print(res.shape)
        # print(f"time mutate elapsed: {time.time() - s}")
